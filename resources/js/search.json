[[{"l":"Welcome","p":["The federated application shell for Workleap apps"]}],[{"l":"Getting started","p":["Welcome to the @squide documentation. This section will give you an overview of @squide and a quick start to create a new federated application from nothing."]},{"l":"Overview","p":["We built this shell to facilitate the adoption of federated applications at Workleap by enforcing patterns that we believe will help feature teams successfully implement a distributed architecture.","The shell itself is a very thin API layer on top of Webpack Module Federation and React Router with the goal of maximizing both libraries forces and staying as most as possible out of their ways."]},{"l":"Webpack Module Federation","p":["We identified 2 major problems with frontend federated applications:","How to prevent loading the same large dependencies twice when switching between modules?","How to offer a cohesive experience that doesn't feels modular?","We believe Webpack Module Federation solves the first problem by offering a mecanism capable of deduping at runtime the common dependencies shared by the host application and the remote modules.","With this mecanism in place, all federated parts of an application can now be loaded in the same browsing context instead of nested browsing contexts (like iframes).","By sharing the same browsing context (e.g. the same Document, the same Window object, and the same DOM), federated parts are now unified and form a single application, which solves the second issues.","With Webpack Module Federation, we believe that we will be able to develop federated applications that feels like monolithic applications \uD83D\uDE80"]},{"l":"React Router","p":["React Router nested routes feature is ideal for federated application as it makes the UI heavily composable and decoupled. Anyway, which else would you use? \uD83D\uDE02"]},{"l":"Module registration","p":["The most distinctive aspect of this shell is the conventions it enforces to load and register remote modules. Here's a rough idea of the flow:","At bootstrap, the host application will try to load predefined modules and call a registration function matching a specific name and signature for each module that is successfully loaded.","During it's registration, a module will receive the shared services of the federation application and use them to dynamically register its routes and navigation items.","Once all the remote modules are registered, the host application will create a React Router instance with the registered routes and render a navigation menu with the registered navigation items.","That's it in a nutshell. Of course, there's more to it, but those are the main ideas."]},{"l":"Guiding principles","p":["While developing the API of @squide, we had a few guiding principles in mind. Those principles are not settled stones, you might want to diverge from them from time to time, but adhering to those will make your experience more enjoyable:","A module should always match a subdomain of the application business domain and should only export pages.","A module should be fully autonomous. It shouldn't have to coordinate with other parts of the application for things as trivial as navigation links.","A federated application should feel homogenous. Different parts of a federation application should have the ability to communicate with each others and react to changes happening outside of their boundaries.","Data and state should never be shared between parts of a federated application. Even if two parts needs the same data or the same state values, they should load, store and manage those independently."]},{"l":"Limitations","p":["Webpack Module Federation comes with a few limitations that are manageable, but important to consider when architecturing your distributed application:","A shared dependency cannot be tree-shaken. Since remote modules are loaded at runtime, ModuleFederationPlugin can't infer which parts of a shared dependency will be used by the application modules. Therefore, tree-shaking is disabled for shared dependencies.","React's Fast Refresh is not supported by Webpack Module Federation. It does support Webpack Hot Module Replacement thought.","Those limitations are not specific to @squide, they are specific to Webpack Module Federation."]}],[{"l":"Create an host application","p":["Let's start by creating the application that will act as the entry point of our federated application and host the modules."]},{"l":"Install the packages","p":["Create a new project (we'll call ours host), then open a terminal at the root of the newly created project and install the following packages:"]},{"l":"Setup the application","p":["First, create the following files:","Then, use a dynamic import to add an async boundary:","To learn more about this async boundary and the bootstrap.tsx file, read the following article.","Then, instanciate the shell Runtime and register the remote module(the remote module application will be configured in the next section):","Next, retrieve the routes registered by the remote module and create a router instance:","Then, create a layout component to render the navigation items:"]},{"l":"Configure Webpack","p":["To add Webpack ModuleFederationPlugin we'll use the hostTransformer function:","View a full webpack.config.js"]},{"i":"try-the-application","l":"Try the application \uD83D\uDE80","p":["Start the application, you should see the home page. Even if the remote module application is not yet available, the host application loads gracefully."]}],[{"l":"Create a remote module","p":["Remote modules are modules that are not part of the current build but are loaded at runtime from a remote server. They are useful because they enable teams to be fully autonomous by deploying their modules independently from the other parts of the application.","Let's add our first remote module!"]},{"l":"Install the packages","p":["Create a new project (we'll call ours remote-module), then open a terminal at the root of the newly created project and install the following packages:"]},{"l":"Setup the application","p":["First, create the following files:","Then, register the remote module routes and navigation items:"]},{"l":"Configure Webpack","p":["To add Webpack ModuleFederationPlugin we'll use the remoteTransformer function:","View a full webpack.config.js on Github"]},{"i":"try-the-application","l":"Try the application \uD83D\uDE80","p":["Start both applications, you should now see an additional link in the navigation menu. Click on the link to navigate to your remote module page!"]}],[{"l":"Create a local module","p":["Local modules are regular modules that are part of the host application build. It's an independent module exposing a registration function to the host application bootstrapping code. It can be a standalone package, a sibling project (when in a monorepo setup), or even a local folder of the host application.","Local modules are useful when migrating from a monolithic application to a distributed application or when launching a new product with an unrefined business domain.","Let's add one to show how it's done!","Loading remote modules at runtime with Webpack Module Federation is the reason why this shell exists and it is what we recommend products to aim for. It enables teams to be fully autonomous by deploying their modules independently from the other parts of the application.","However, we understand that teams working on mature products will most likely prefer to gradually migrate towards a distributed architecture by first extracting subdomains into independent modules in their current monolithic setup before fully committing to remote modules loaded at runtime.","To facilitate the transition, this shell also supports local modules loaded at build time.","Both remote and local modules can be used in the same application as this shell supports dual bootstrapping. For example, an application could be configured to load a few remote modules at runtime and also load a few local modules at build time."]},{"l":"Install the packages","p":["Create a new project (we'll call ours local-module), then open a terminal at the root of the newly created project and install the following packages:"]},{"l":"Setup the application","p":["First, create the following files:","Then, add the following fields to the package.json files:","Then, register the local module routes and navigation items:"]},{"l":"Load the local module","p":["Go back to the host application and load the local module. Don't forget to add a dependency in the host application package.json file."]},{"i":"try-the-application","l":"Try the application \uD83D\uDE80","p":["Start both applications, you should now see a third link in the navigation menu. Click on the link to navigate to your local module page!"]}],[{"l":"Learn the API","p":["Now that we've created an host application, loaded a few modules and registered routes and navigation items, let's dive into the APIs that are available with this shell.","For an exhaustive list of @squide API, have a look at the References section."]},{"l":"Logging","p":["@squide comes with a native logging feature integrated with the Runtime class and the useLogger hook.","First, register your own custom logger by implementing the Logger interface or with @squide native ConsoleLogger:","Then, log entries any parts of your federated application with the useLogger hook:","The logger is also available from the Runtime instance."]},{"l":"Messaging","p":["It's important that the parts of a federated application remains loosely coupled. To help with that, @squide offers a native Event Bus functionality.","First, listen to an event with the useEventBusListener hook:","Then, dispatch an event from anywhere with the useEventBusDispatcher hook:","The event bus is also available from the Runtime instance."]},{"l":"Session","p":["Most of our applications (if not all) will eventually require the user to authenticate. To support that, @squide Runtime class accepts a sessionAccessor function that is made available to every module of the application once the registration flow is completed.","First, define a sessionAccessor function:","Our security department reminds you to not use a fake SessionManager in a production application \uD83D\uDE0A","Then register the accessor function:","Finally, retrieve the session from any parts of the application with the useSession hook:","Or determine whether or not the user is authenticated with the useIsAuthenticated hook:","The session is also available from the Runtime instance."]},{"l":"Services","p":["@squide offers a few built-in services, however, by no mean these services alone can support the needs of every mature application. That's why custom services can be added to the shell Runtime.","First, make the service available to every part of the application by passing a service instance to the Runtime instance:","Then, retrieve the service instance from anywhere with the useService hook:","The services are also available from the Runtime instance."]}],[{"l":"Deploy","p":["The deployment of a federated application could vary based on many factors, including the choice of the hosting provider. Therefore, we don't recommend any specific deployment setup.","Still, there are a few things that must be configured independently of your deployment choices."]},{"l":"Default redirect","p":["To support direct page hits, add the following redirect to the host application hosting provider:"]}],[{"l":"Guides","p":["Override the host layout","Isolate module failures","Add authentication","Implement a custom logger","Migrating from a monolithic application"]}],[{"l":"Override the host layout","p":["Most application pages usually share a common layout with at least: a navigation bar, a user profile menu and a main content section. In a React Router's application, this common layout is what we call a RootLayout:","In the previous code sample, the RootLayout is the default layout for the home page and every page (route) registered by a module.","For most pages, this is the behavior expected by the author. However, for pages such as a login page, the default RootLayout isn't a good fit because a login page is not bound to a user session (the user is not even authenticated yet).","Those pages in need of a different layout require a mechanism to pull out their route declaration at the root of the React Router's router instance, before the RootLayout is declared.","Package managers supporting workspaces such as Yarn and NPM call this mechanism \"hoisting\", which means \"raise (something) by means of ropes and pulleys\". This is exactly what we are trying to achieve here.","@squide has a built-in useHoistedRoutes hook capable of raising module routes marked as hoist at the root of the routes array, before the RootLayout declaration. Thus, an hoisted page will not be wrapped by the RootLayout and will have full control over its rendering.","To hoist module pages, first transform the module routes with the useHoistedRoutes hook before creating the router instance:","Then, mark the pages as hoisted and optionally use a new layout:","For additional options, go to the useHoistedRoutes hook reference page"]}],[{"l":"Isolate module failures","p":["One of the key characteristics of micro-frontends implementations like iframes and subdomains is that a single remote module failure can't break the whole application.","With a Webpack Module Federation implementation, this is not the case as all the remote modules share the same browsing context (e.g. the same Document, the same Window object, and the same DOM).","Still, we can get very close to iframes failure isolation by leveraging React Router's Outlet component and routes' errorElement property:","In the previous code sample, a RootErrorBoundary is declared under the RootLayout but over the remote module routes. By doing so, if a module cause an unmanaged error, the nested error boundary will only replace the section rendered by the Outlet component of the RootLayout instead of the whole page.","With this mechanism, failure isolation is as good as with an iframes or subdomains implementation.","If your application is hoisting page, they will be rendered outside of the host application's root error boundary. To avoid breaking the entire application when an hoisted page cause unmanaged errors, it is highly recommended to declare a React Router errorElement property on every hoisted page."]}],[{"l":"Add authentication","p":["Most of our applications (if not all) will eventually require the user to authenticate. To support that, @squide Runtime class accepts a sessionAccessor function that is made available to every module of the application once the registration flow is completed.","When combined with a React Router's authentication boundary and a login page, the shared sessionAccessor function is a great asset to handle authentication concerns.","First, define a sessionAccessor function:","Our security department reminds you to not use a fake SessionManager in a production application \uD83D\uDE0A","Then create a Runtime instance with the new sessionAccessor function:","Then create an authentication boundary component using the useIsAuthenticated hook:","Internally, the useIsAuthenticated hook use the sessionAccessor function to determine whether or not the user is authenticated.","Then, add a login page:","And finally, assemble everything with React Router's nested routes:","Now, start the application and try navigating to the root page (/). You should be redirected to the /login page. Login with temp/ temp, you should now be redirected to the root page."]}],[{"l":"Implement a custom logger","p":["Many applications must integrate with specific remote logging solutions like Honeycomb and Azure Application Insights. To help with that, the shell runtime accepts any custom loggers that implement the Logger interface.","First, let's define a custom logger:","Then create a Runtime instance with an instance of the new CustomLogger:","Start the applications and open the dev tools. Refresh the page. The console logs should be displayed:"]}],[{"l":"Migrating from a monolithic application","p":["It's easier to build a new federated application from scratch than retrofitting an existing monolithic application into a distributed architecture.","However, it's also a bad idea to start a new application with a distributed architecture because teams usually don't know enough about their business domain at that time. Therefore, it usually makes sense for most applications to start as monolithic and later on be transitioned to federated applications.","With the introduction of local modules, we believe @squide offer a new proposition which stands right in the middle of prior solutions. Instead of going full steam into Team Topology's stream-aligned teams and targeting full team autonomy across the board, with local modules, teams can start with a monorepo setup and add an independent local package (module) per expected value stream.","Since adding/deleting local packages in a monorepo setup is pretty cheap, teams won't fear reorganizing their value streams along the way and won't invest preemptively into a distributed CI/CD infrastructure as local modules are part of the host application build. With independent value streams, teams will be well-positioned to transition toward a federated application once they can justify the cost.","If your project is already a monolithic application with a polyrepo setup and you are looking to migrate to a distributed architecture, we also recommend a decoupling first strategy with local modules and a monorepo setup."]},{"l":"Decoupling first","p":["The main obstacle toward migrating to a distributed architecture is coupling. Thus, starting by decoupling the monolith into composable value streams could be the right strategy for most applications. It's a great way to get into the migration without having to immediately update the CI/CD infrastructure and change developers habits.","We recommend the following steps:","1- Transform the codebase into a monorepo setup.","2- Add independent local packages (modules) for every identified value stream.","3- Move the monolithic application code to their corresponding newly created value stream local packages and make sure a value stream can be developed independently(e.g. without having to start the whole application).","4- Import and register the local packages(modules) into the host application.","5- Finally, move from local modules to remote modules and update the CI/CD pipelines to start deploying modules independently."]}],[{"l":"References"},{"l":"Artefacts","p":["Packages"]},{"l":"API"},{"l":"Runtime","p":["Runtime class","RuntimeContext","useRuntime","useRoutes","useNavigationItems","useLogger","useService","useServices","useSession"]},{"l":"Registration","p":["registerLocalModules","registerRemoteModules","registrationStatus","useAreRemotesReady"]},{"l":"Routing","p":["useHoistedRoutes","useRenderedNavigationItems"]},{"l":"Logging","p":["Logger","ConsoleLogger"]},{"l":"Messaging","p":["EventBus","useEventBusDispatcher","useEventBusListener"]},{"l":"Session","p":["useIsAuthenticated"]},{"l":"Webpack","p":["hostTransformer","remoteTransformer"]},{"l":"Fakes","p":["@squide offers a collection of fake implementations to facilitate the development of modules in isolation from the other parts of the application.","SessionManager"]}],[{"l":"Packages","p":["Name","NPM","@squide/core","npm version","@squide/react-router","@squide/webpack-module-federation","@squide/fakes"]}],[{"l":"Runtime class","p":["A runtime instance give modules access to functionalities such as routing, navigation and logging."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options.","loggers: An optional array of Logger instances.","services: An optional string-keyed object literal of custom service instances.","sessionAccessor: An optional function returning the current session."]},{"l":"Usage"},{"l":"Create a Runtime instance"},{"l":"Register routes","p":["A @squide route accept any properties of a React Router Route component with the addition of an hoist property."]},{"l":"Register an hoisted page","p":["Unlike a regular page, a hoisted page is added at the root of the router, outside of the boundaries of the host application's root layout. This means that a hoisted page has full control over its rendering.","Setup the host application to accept hoisted routes"]},{"l":"Register navigation items","p":["A @squide navigation item can either be a NavigationLink or a NavigationSection. Both types can be intertwined to create a multi-level menu hierarchy. A NavigationSection item is used to setup a new level while a NavigationLink define a link.","NavigationSection accept the following properties:","label: The section text.","children: The section content.","priority: An order priority affecting the position of the item in the menu (higher first)","addiltionalProps: Additional properties to be forwarded to the section renderer.","NavigationLink accept any properties of a React Router Link component with the addition of:","label: The link text.","additionalProps: Additional properties to be forwarded to the link renderer.","Setup the host application to render navigation items"]},{"l":"Register nested navigation items"},{"l":"Sort registered navigation items","p":["A priority property can be added to a navigation item to affect it's position in the menu. The sorting algorithm is as follow:","By default a navigation item have a priority of 0.","If no navigation item have a priority, the items are positioned according to their registration order.","If an item have a priority 0, the item will be positioned before any other items with a lower priority (or without an explicit priority value).","If an item have a priority 0, the item will be positioned after any other items with a higher priority (or without an explicit priority value)."]},{"l":"Use a React Element as navigation item label"},{"l":"Style a navigation item"},{"l":"Open a navigation link in a new tab"},{"l":"Render additional props on a navigation item"},{"l":"Use the logger"},{"l":"Use the event bus"},{"l":"Retrieve a service"},{"l":"Retrieve the current session"}],[{"l":"RuntimeContext","p":["React context to share a Runtime instance between an host application and the modules."]},{"l":"Reference"},{"l":"Parameters","p":["value: A Runtime instance."]},{"l":"Usage"},{"l":"Provide a Runtime instance"},{"l":"Retrieve a Runtime instance"}],[{"l":"useRuntime","p":["Retrive a shared Runtime instance.","When possible, prefer useRoutes, useNavigationItems, useLogger, useServices, useService to useRuntime."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A Runtime instance."]},{"l":"Usage"}],[{"l":"useRoutes","p":["Retrieve the registered routes from the Runtime instance provided by RuntimeContext."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["An array of Route."]},{"l":"Usage"}],[{"l":"useNavigationItems","p":["Retrieve the registered navigation items from the Runtime instance provided by RuntimeContext."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["An array of NavigationItem."]},{"l":"Usage"}],[{"l":"useLogger","p":["Retrieve a RuntimeLogger instance from the Runtime instance provided by RuntimeContext."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A RuntimeLogger instance."]},{"l":"Usage"}],[{"l":"useService","p":["Retrieve a custom service from the Runtime instance provided by RuntimeContext."]},{"l":"Reference"},{"l":"Parameters","p":["name: A custom service instance name."]},{"l":"Returns","p":["A service instance or undefined if the specified service name doesn't match any registered instance."]},{"l":"Usage"}],[{"l":"useServices","p":["Retrieve a string-keyed object literal of custom service instances from the Runtime instance provided by RuntimeContext."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A string-keyed object literal of custom service instances."]},{"l":"Usage"}],[{"l":"useSession","p":["Retrieve the current session from the Runtime instance provided by RuntimeContext."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A custom session object."]},{"l":"Usage"}],[{"l":"registerLocalModules","p":["Register one or many local module(s). During registration, the provided registration function will be called with a Runtime instance and an optional context object.","A local module is a regular module which is part of the host application build and is bundled at build time rather than runtime like a remote module. Local modules are useful while migrating from a monolithic application to a distributed application or launching a new product with an unrefined business domain."]},{"l":"Reference"},{"l":"Parameters","p":["registerFunctions: An array of ModuleRegisterFunction.","runtime: A Runtime instance.","options: An optional object literal of options.","context: An optional context object that will be pass to the registration function."]},{"l":"Returns","p":["Nothing"]},{"l":"Usage"}],[{"l":"registerRemoteModules","p":["Register one or many remote module(s). During registration, the module register function will be called with a Runtime instance and an optional context object.","A remote module is a module that is not part of the current build but is loaded at runtime from a remote server."]},{"l":"Reference"},{"l":"Parameters","p":["remotes: An array of RemoteDefinition(view the Remote definition section).","runtime: A Runtime instance.","options: An optional object literal of options.","context: An optional context object that will be pass to the registration function."]},{"l":"Returns","p":["A Promise object with an array of [RegistrationError] if any happens during the registration."]},{"l":"Usage"},{"l":"Remote definition","p":["To ease the configuration of remote modules, make sure that you first import the RemoteDefinition type and assign it to your remote definitions array declaration."]},{"l":"Name","p":["The name property of a remote definition must match the name property defined in the remote module ModuleFederationPlugin configuration.","If you are using @squide remoteTransformer function to add the ModuleFederationPlugin to the remote module Webpack configuration object, the remote module name is the second argument of the remoteTransformer function.","In the following exemple, the remote module name is remote1.","View the remoteTransformer function"]},{"l":"Url","p":["The url property of a remote definition must match the publicPath of the remote module Webpack configuration object.","In the following exemple, the remote module publicPath is http://localhost:8081."]}],[{"l":"registrationStatus","p":["Variable indicating whether or not the remote modules registration is completed."]},{"l":"Usage"}],[{"l":"useAreRemotesReady","p":["Force the application to re-render once the remote modules are registered. Without this hook, the page is rendered with an empty router as it happens before the remote modules registered their routes and navigation items.","Only use this hook if your application loads remote modules."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options.","interval: The interval in milliseconds at which the hook is validating if the registration process is completed."]},{"l":"Returns","p":["A boolean indicating if the registration is completed."]},{"l":"Usage"}],[{"l":"useHoistedRoutes","p":["Allow modules to register pages outside of the host application's pages boundaries. Unlike a regular page, an hoisted page is added at the root of the router, meaning before the host application root layout, root error boundary and even root authentication boundary. Thus, an hoisted page has full control over its rendering.","By declaring a page as hoisted, other parts of the application will not be isolated anymore from this page's failures as the page will be rendered outside of the host application's root error boundary. To avoid breaking the entire application when an hoisted page cause unmanaged errors, it is highly recommended to declare a React Router errorElement property on every hoisted page."]},{"l":"Reference"},{"l":"Parameters","p":["routes: An array of Route to process.","wrapManagedRoutes: A function nesting the managed routes under React elements such as a layout, an error boundary or an authentication boundary.","options: An optional object literal of options.","allowedPaths: An optional array of exclusive route paths available for hosting."]},{"l":"Returns","p":["An array of Route."]},{"l":"Usage"},{"l":"Hoist a module page"},{"l":"Register a module page with a different layout","p":["For a detailed walkthrough, read the guide on how to override the host layout."]},{"l":"Register a public page"},{"l":"Allowing an exclusive set of routes to be hoisted"}],[{"l":"useRenderedNavigationItems","p":["Recursively parse a navigation items structure to transform the items into React Elements.","The useNavigationItems hook returns the navigation items tree structure as is, meaning the consumer has to recursively parse the structure to transform the items into actual React Elements.","As it's a non-trivial process, the shell provides this utility hook to help with that."]},{"l":"Reference"},{"l":"Parameters","p":["navigationItems: An array of NavigationItem to render.","renderItem: A function to render a single link from a navigation item","renderSection: A function to render a section from a collection of items."]},{"l":"Returns","p":["An array of ReactElement."]},{"l":"Usage"}],[{"l":"ConsoleLogger","p":["A basic console logger."]},{"l":"Reference"},{"l":"Parameters","p":["logLevel: An optional minimum level for the logger to output a log entry to the console (default is LogLevel.critical)."]},{"l":"Usage"}],[{"l":"Logger","p":["A basic logger interface."]},{"l":"Usage"}],[{"l":"EventBus","p":["A basic implementation of a pub/sub mecanism enabling loosely coupled between the host application and the modules."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options.","logger: An optional logger to facilitate debugging."]},{"l":"Usage"},{"l":"Create an EventBus instance"},{"l":"Add a listener","p":["When possible, prefer useEventBusListener to eventBus.addListener."]},{"l":"Remove a listener"},{"l":"Dispatch an event","p":["When possible, prefer useEventBusDispatcher to eventBus.dispatch."]}],[{"l":"useEventBusDispatcher","p":["Retrieve an EventBus instance from the Runtime instance provided by RuntimeContext and provide a function to dispatch an event."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A dispatch function."]},{"l":"Usage"}],[{"l":"useEventBusListener"},{"l":"Reference"},{"l":"Parameters","p":["eventName: The name of the event to listen for.","callback: A function to be executed when a event matching the provided name is dispatched.","options: An optional object literal of options.","once: Whether or not the event listener should be automatically removed once an event as been handled."]},{"l":"Returns","p":["Nothing"]},{"l":"Usage"}],[{"l":"useIsAuthenticated","p":["Indicate whether or not the user is authenticated.","If the sessionAccessor function return a non null/ undefined value, a user is considered as authenticated."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A boolean value."]},{"l":"Usage"}],[{"l":"hostTransformer","p":["Add to an existing Webpack configuration object a ModuleFederationPlugin plugin instance pre-configured for a @squide host application."]},{"l":"Reference"},{"l":"Parameters","p":["config: A Webpack configuration object.","name: The host application name.","options: An optional object literal of options.","router: An optional router identifier (default is react-router).","pluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["A Webpack configuration object enriched with a ModuleFederationPlugin plugin instance."]},{"l":"Default shared dependencies","p":["The hostTransformer function will add the following shared dependencies as singleton by default:","react","react-dom","react-router-dom","@squide/core","@squide/react-router","@squide/webpack-module-federation","For the full shared dependencies configuration, have a look at the configTransformer.ts file on Github."]},{"l":"Usage"},{"l":"Transform a Webpack config"},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Override a default shared dependency"}],[{"l":"remoteTransformer","p":["Add to an existing Webpack configuration object a ModuleFederationPlugin plugin instance pre-configured for a @squide remote module application."]},{"l":"Reference"},{"l":"Parameters","p":["config: A Webpack configuration object.","name: The remote application name.","options: An optional object literal of options.","router: An optional router identifier (default is react-router).","pluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["A Webpack configuration object enriched with a ModuleFederationPlugin plugin instance."]},{"l":"Conventions","p":["To fulfil @squide remote module requirements, the remoteTransformer function will pre-configure the ModuleFederationPlugin with the following filename and exposes properties.","If the remote module publicPath is http://localhost:8081, the remote module bundle is available at http://localhost:8081/remoteEntry.js."]},{"l":"Default shared dependencies","p":["The remoteTransformer function will add the following shared dependencies as singleton by default:","react","react-dom","react-router-dom","@squide/core","@squide/react-router","@squide/webpack-module-federation","For the detailed configuration of the shared dependencies, have a look at the configTransformer.ts file on Github."]},{"l":"Usage"},{"l":"Transform a Webpack config"},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Override a default shared dependency"},{"l":"Expose an additional module"}],[{"l":"SessionManager","p":["A local session manager strictly for development purpose."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options.","key: An optional key identifying the session in localStorage."]},{"l":"Usage"},{"l":"Create a SessionManager instance"},{"l":"Set a session"},{"l":"Get the current session"},{"l":"Clear the current session"},{"l":"Integrate with a Runtime instance"}],[{"l":"Samples"},{"i":"squide-sandbox","l":"@squide sandbox","p":["Host application","Remote module","Local module","Live sample"]}],[{"l":"About","p":["To ask a question or propose an idea, feel free to start a new discussion on Github. If you found a bug, please open an issue on Github."]},{"l":"Contributing","p":["Have a look at the contributor's documentation."]},{"l":"License","p":["See the @squide LICENSE on Github."]}]]