[[{"l":"Getting started","p":["Welcome to @squide(yes \uD83E\uDD91 with an \"e\"), a shell for Workleap federated applications. In this getting started section, you'll find an overview of the shell and a quick start guide to create a new federated application from scratch.","The prefered way for creating a new federated application for the Workleap's platform is with the foundry-cli."]},{"l":"Why","p":["We have built this shell to facilitate the adoption of federated applications at Workleap by enforcing patterns that we believe will help feature teams successfully implement a distributed architecture.","The shell itself is a lightweight API layer built on top of Module Federation and React Router, with the goal of maximizing the strength of both libraries while interfering as little as possible with their functionality."]},{"l":"Module Federation","p":["We have identified 2 major challenges with frontend federated applications:","How can we prevent loading the same large dependencies twice when switching between modules?","How can we offer a cohesive experience that doesn't feel modular?","To address the first challenge, we believe that Module Federation provides a solution by offering a mecanism capable of deduping common dependencies shared between the host application and the remote modules at runtime.","With this mecanism in place, all federated parts of an application can now be loaded in the same browsing context instead of nested browsing contexts such as iframes.","By sharing the same browsing context (e.g. the same Document object, the same Window object, and the same DOM), federated parts now form a unified and cohesive single application, addressing the second challenge.","With Module Federation, we believe that we can develop federated applications that provide the same user experience as monolithic applications \uD83D\uDE80"]},{"l":"React Router","p":["React Router nested routes feature is ideal for federated applications as it enables highly composable and decoupled UI. Besides, what else would you use? \uD83D\uDE02"]},{"l":"Module registration","p":["The most distinctive aspect of this shell is the conventions it enforces for loading and registering remote modules. Here's a brief overview of the flow:","During bootstrap, the host application attempts to load predefined modules and calls a registration function with a specific name and signature for each successfully loaded module.","During registration, a module receives the shared services of the federation application and use them to dynamically register its routes and navigation items.","Once all the modules are registered, the host application will create a React Router instance with the registered routes and renders a navigation menu with the registered navigation items.","That's a nutshell overview. Of course, there is more to it, but these are the main ideas."]},{"l":"Guiding principles","p":["While developing the API of @squide, we kept a few guiding principles in mind. Those principles are not settled stones, you might want to diverge from them from time to time, but adhering to those will make your experience more enjoyable:","A module should always correspond to a subdomain of the application's business domain and should only export pages.","A module should be fully autonomous. It shouldn't have to coordinate with other parts of the application for things as trivial as navigation links.","A federated application should feel cohesive. Different parts of a federation application should have the ability to communicate with each others and react to changes happening outside of their boundaries.","Data and state should never be shared between parts of a federated application. Even if two parts require the same data or the same state values, they should load, store and manage them independently."]},{"l":"Limitations","p":["Module Federation comes with a few manageable limitations that are important to consider when architecting your distributed application:","A shared dependency cannot be tree-shaken. Since remote modules are loaded at runtime, ModuleFederationPlugin cannot infer which parts of a shared dependency will be used by the application modules. Therefore, tree-shaking is disabled for shared dependencies.","Module Federation does not support React Fast Refresh. However, it does support Hot Module Replacement.","These limitations are not specific to @squide, they are specific to Module Federation."]},{"l":"Create your project","p":["To get started, follow the quick start guide to create a new federated application from scratch."]}],[{"l":"Create an host application","p":["Let's begin by creating the application that will serve as the entry point for our federated application and host the application modules."]},{"l":"1. Install the packages","p":["Create a new application (we'll refer to ours as host), then open a terminal at the root of the new solution and install the following packages:","While you can use any package manager to develop an application with @squide, it is highly recommended that you use PNPM as the following guide has been developed and tested with PNPM."]},{"l":"2. Setup the application"},{"l":"Create the new files","p":["First, create the following files:"]},{"l":"ESM syntax","p":["Then, ensure that you are developing your application using ESM syntax by specifying type: module in your package.json file:"]},{"l":"Async boundary","p":["Then, use a dynamic import to add an async boundary:","To learn more about this async boundary and the bootstrap.tsx file, read the following article."]},{"l":"Module registration","p":["Then, instanciate the shell Runtime and register the remote module(the configuration of the remote module will be covered in the next section):"]},{"l":"Router instance","p":["Then, retrieve the routes that have been registered by the remote module and create a router instance:","And finally, create the Home component:"]},{"l":"Navigation items","p":["FInally, create a layout component to render the navigation items:"]},{"l":"3. Configure webpack","p":["@squide webpack configuration is built on top of @workleap/webpack-configs, @workleap/browserslist-config and @workleap/swc-configs. If you are having issues with the configuration of these tools, refer to the tools documentation websites."]},{"l":"HTML template","p":["First, open the public/index.html file created at the beginning of this guide and copy/paste the following HtmlWebpackPlugin template:"]},{"l":"Browserslist","p":["Then, open the .browserslist file and copy/paste the following content:"]},{"l":"Development configuration"},{"l":"SWC","p":["To configure webpack for a development environment, first open the swc.dev.js file and copy/paste the following code:"]},{"l":"defineDevHostConfig","p":["Then, open the webpack.dev.js file and use the defineDevHostConfig function to configure webpack:","If you are having issues with the wepack configuration that are not related to module federation, refer to the @workleap/webpack-configs documentation."]},{"l":"Build configuration"},{"i":"swc-1","l":"SWC","p":["To configure webpack for a build environment, first open the swc.build.js file and copy/paste the following code:"]},{"l":"defineBuildHostConfig","p":["Then, open the webpack.build.js file and use the defineBuildHostConfig function to configure webpack:","If you are having issues with the wepack configuration that are not related to module federation, refer to the @workleap/webpack-configs documentation."]},{"l":"4. Add CLI scripts","p":["To initiate the development server, add the following script to the application package.json file:","To build the application, add the following script to the application package.json file:"]},{"i":"5-try-the-application","l":"5. Try the application \uD83D\uDE80","p":["Start the application in a development environment using the dev script. You should see the home page. Even if the remote module application is not yet available, the host application will gracefully load."]}],[{"l":"Create a remote module","p":["Remote modules are modules that are not included in the host application build but are instead loaded at runtime from a remote server. They provide a way for teams to be fully autonomous by independently deploying their modules without relying on the other parts of the application.","Let's add our first remote module!"]},{"l":"1. Install the packages","p":["Create a new application (we'll refer to ours as remote-module), then open a terminal at the root of the new solution and install the following packages:","While you can use any package manager to develop an application with @squide, it is highly recommended that you use PNPM as the following guide has been developed and tested with PNPM."]},{"l":"2. Setup the application"},{"l":"Create the new files","p":["First, create the following files:"]},{"l":"ESM syntax","p":["Then, ensure that you are developing your module using ESM syntax by specifying type: module in your package.json file:"]},{"l":"Routes and navigation items registration","p":["Then, register the remote module routes and navigation items:","And finally, create the Page component:"]},{"l":"3. Configure webpack","p":["@squide webpack configuration is built on top of @workleap/webpack-configs, @workleap/browserslist-config and @workleap/swc-configs. If you are having issues with the configuration of these tools, refer to the tools documentation websites."]},{"l":"Development configuration"},{"l":"SWC","p":["To configure webpack for a development environment, first open the swc.dev.js file and copy/paste the following code:"]},{"l":"defineDevRemoteModuleConfig","p":["Then, open the webpack.dev.js file and use the the defineDevRemoteModuleConfig function to configure webpack:","If you are having issues with the wepack configuration that are not related to module federation, refer to the @workleap/webpack-configs documentation."]},{"l":"Build configuration"},{"i":"swc-1","l":"SWC","p":["To configure webpack for a build environment, first open the swc.build.js file and copy/paste the following code:"]},{"l":"defineBuildRemoteModuleConfig","p":["Then, open the webpack.build.js file and use the the defineBuildRemoteModuleConfig function to configure webpack:","If you are having issues with the wepack configuration that are not related to module federation, refer to the @workleap/webpack-configs documentation."]},{"l":"4. Add CLI scripts","p":["To initiate the development server, add the following script to the application package.json file:","To build the module, add the following script to the application package.json file:"]},{"i":"5-try-the-application","l":"5. Try the application \uD83D\uDE80","p":["Start the host and the remote-module applications in development mode using the dev script. You should notice an additional link in the navigation menu. Click on the link to navigate to the page of your new remote module!"]}],[{"l":"Create a local module","p":["Local modules are regular modules that are part of the host application build. They are independent modules that expose a registration function to the host application's bootstrapping code. A local module can be a standalone package, a sibling project (in a monorepo setup), or even a local folder within the host application.","Local modules are useful when migrating from a monolithic application to a distributed application or when launching a new product with an unrefined business domain.","Let's add a local module to demonstrate how it's done!","Loading remote modules at runtime with Module Federation is the primary focus of this shell and our recommended approach. It empowers teams to be fully autonomous by deploying their modules independently from the other parts of the application.","However, we recognize that teams working on mature products may prefer to gradually migrate to a distributed architecture by first extracting subdomains into independent modules within their current monolithic setup before fully committing to remote modules loaded at runtime.","To facilitate this transition, this shell also supports local modules that are loaded at build time.","Both remote and local modules can be used within same application as this shell supports dual bootstrapping. For example, an application can be configured to load a few remote modules at runtime while also loading a few local modules."]},{"l":"1. Install the packages","p":["Create a new application (we'll refer to ours as local-module), then open a terminal at the root of the new solution and install the following packages:","While you can use any package manager to develop an application with @squide, it is highly recommend that you use PNPM as the following guide has been developed and tested with PNPM."]},{"l":"2. Setup the application"},{"l":"Create the new files","p":["First, create the following files:"]},{"l":"ESM syntax","p":["Then, ensure that you are developing your module using ESM syntax by specifying type: module in your package.json file:","Then, configure the package to be shareable by adding the name, version, and export fields to the package.json file:"]},{"l":"Routes and navigation items registration","p":["Then, register the local module routes and navigation items:","And finally, create the Page component:"]},{"l":"3. Register the local module","p":["Go back to the host application add a dependency to the @sample/local-module package in the host application package.json file:","Then, register the local module:"]},{"l":"4. Configure tsup","p":["If you are having issues with the tsup configuration, refer to the @workleap/tsup-configs documentation."]},{"l":"Development configuration","p":["To configure tsup for a development environment, open the tsup.dev.ts file and copy/paste the following code:"]},{"l":"Build configuration","p":["To configure tsup for a build environment, open the tsup.build.ts file and copy/paste the following code:"]},{"l":"5. Add CLI scripts","p":["To initiate the development server, add the following script to the application package.json file:","To build the module, add the following script to the application package.json file:"]},{"i":"6-try-the-application","l":"6. Try the application \uD83D\uDE80","p":["Start the host, remote-module and local-module applications in development mode using the dev script. You should now notice an additional link in the navigation menu. Click on the link to navigate to the page of your new local module!"]}],[{"l":"Learn the API","p":["Now that we've created a host application, loaded a few modules and registered routes and navigation items, let's delve into the APIs provided by this shell.","For a comprehensive list of the @squide API, refer to the References section."]},{"l":"Runtime mode","p":["In an effort to optimize the development experience, @squide can be bootstrapped in development or production mode:","By default, the Runtime mode is development."]},{"l":"Logging","p":["@squide includes a built-in logging feature that integrates with the Runtime class and the useLogger hook.","First, register your own custom logger by implementing the Logger interface or register @squide built-in ConsoleLogger:","Then, log entries from any parts of your federated application with the useLogger hook:","The logger is also available from the Runtime instance."]},{"l":"Messaging","p":["It's crucial that the parts of a federated application remains loosely coupled. To help with that, @squide offers a built-in Event Bus.","First, listen to an event with the useEventBusListener hook:","Then, dispatch an event from anywhere with the useEventBusDispatcher hook:","You can use the event bus to enable various communication scenarios, such as notifying components of state changes, broadcasting messages across modules, or triggering actions based on specific events.","The event bus is also available from the Runtime instance."]},{"l":"Session","p":["Most of our applications (if not all) will eventually require the user to authenticate. To facilitate this process, the @squide Runtime class accepts a sessionAccessor function. Once the shell registration flow is completed, the function will be made accessible to every module of the application.","First, let's define a sessionAccessor function:","Our security department reminds you to refrain from using a fake LocalStorageSessionManager in a production application \uD83D\uDE0A","Then register the accessor function:","Finally, access the session from any parts of the application with the useSession hook:","Or determine whether or not the user is authenticated with the useIsAuthenticated hook:","The session is also available from the Runtime instance."]},{"l":"Services","p":["While @squide provides a range of built-in functionalities, by no mean these alone can support the needs of every mature application. Therefore, the shell Runtime allows the addition of custom services.","First, make the service available to every part of the application by passing a service instance to the Runtime instance:","Then, access the service instance from anywhere with the useService hook:","The services are also available from the Runtime instance."]}],[{"l":"Deploy","p":["The deployment process for a federated application can vary depending on various factors, including the chosen hosting provider. Therefore, we do not recommend any specific deployment setup.","However, there are a few essential configurations that need to be made regardless of your deployment choices."]},{"l":"Default redirect","p":["To enable support for direct page hits, add the following redirect rule to your host application's hosting provider:"]},{"l":"Remote URL","p":["Updates the application remote module production URL:"]},{"l":"Runtime mode","p":["Don't forget to change the Runtime mode to production:"]},{"l":"Console logger","p":["We suggest to remove ConsoleLogger for the production build:"]}],[{"l":"Guides","p":["Override the host layout","Isolate module failures","Add authentication","Implement a custom logger","Develop a module in isolation","Migrating from a monolithic application"]}],[{"l":"Override the host layout"},{"l":"Root layout","p":["In many applications, multiple pages often share a common layout that includes elements such as a navigation bar, a user profile menu, and a main content section. In a React Router application, this shared layout is commonly referred to as a RootLayout:","In the previous code sample, the RootLayout serves as the default layout for the home page as well as for every page (route) registered by a module.","For most pages, this is the behavior expected by the author. However, for pages such as a login page, the default RootLayout isn't suitable because the page is not bound to a user session (the user is not even authenticated yet).","To accomodate pages that require a different layout, a mechanism is needed to move their route declaration at the root of the React Router router instance, before the RootLayout is declared."]},{"l":"Hoisting","p":["Package managers supporting workspaces such as Yarn and NPM call this mechanism \"hoisting\", which means \"raise (something) by means of ropes and pulleys\". This is exactly what we are trying to achieve here.","@squide has a built-in useHoistedRoutes hook capable of raising module routes marked as hoist at the root of the routes array, before the RootLayout declaration. Thus, an hoisted page will not be wrapped by the RootLayout and will have full control over its rendering.","To hoist module pages, first transform the module routes with the useHoistedRoutes hook before creating the router instance:","Then, mark the pages as hoisted and optionally use a new layout:","For additional options, go to the useHoistedRoutes hook reference page"]}],[{"l":"Isolate module failures","p":["One of the key characteristics of micro-frontends implementations like iframes and subdomains is the ability to isolate failures within individual remote modules, preventing them from breaking the entire application.","However, in a Module Federation implementation, this is not the case as all the remote modules share the same browsing context (e.g. the same Document object, the same Window object, and the same DOM). A failure in one remote module can potentially breaks the entire application.","Nevertheless, an application can get very close to iframes failure isolation by utilizing React Router's Outlet component and the errorElement property of a React Router's routes."]},{"l":"Error boundary","p":["In the following code sample, a RootErrorBoundary is declared below the RootLayout but above the routes of the remote module. By doing so, if a module encounters an unhandled error, the nested error boundary will only replace the section rendered by the Outlet component within the RootLayout rather than the entire page:","By implementing this mechanism, the level of failure isolation achieved is comparable to that of an iframes or subdomains implementation. With this mechanism, failure isolation is as good as with an iframes or subdomains implementation.","If your application is hoisting page, it's important to note that they will be rendered outside of the host application's root error boundary. To prevent breaking the entire application when an hoisted page encounters unhandled errors, it is highly recommended to declare a React Router's errorElement property for each hoisted page."]}],[{"l":"Add authentication","p":["Most of our applications (if not all) will eventually require the user to authenticate. To facilitate this process, the @squide Runtime class accepts a sessionAccessor function. Once the shell registration flow is completed, the function will be made accessible to every module of the application.","When combined with a React Router authentication boundary and a login page, the shared sessionAccessor function is of great help to manage authentication concerns."]},{"l":"Session accessor","p":["Define a sessionAccessor function wrapping a LocalStorageSessionManager instance:","Then create a Runtime instance with the new sessionAccessor function:","Our security department reminds you to refrain from using a fake LocalStorageSessionManager in a production application \uD83D\uDE0A"]},{"l":"Authentication boundary","p":["Create a new React Router authentication boundary component using the useIsAuthenticated hook:","Internally, the useIsAuthenticated hook utilize the sessionAccessor function that we created previously to determine whether or not the user is authenticated."]},{"l":"Login page","p":["Add a login page to the application:"]},{"l":"Logout page","p":["Add a logout page to the application:","The logout page also takes care of clearing the current session, allowing you to simply redirect to the page to clear the current user session:"]},{"l":"Authenticated layout","p":["With authentication in place, we now expect to render the navigation items only to authenticated users and to offer a way to logout from the application. To do so, let's introduce a new AuthenticatedLayout:","Most of the layout code has been moved from the RootLayout to the AuthenticatedLayout, leaving the root layout only taking care for now of styling the outer wrapper of the application:"]},{"l":"Nested routes","p":["Assemble everything with React Router nested routes:"]},{"i":"try-the-application","l":"Try the application \uD83D\uDE80","p":["Start the application and attempt navigating to the root page (/). You will be redirected to the /login page. Login with temp/ temp, you will be redirected to the root page."]}],[{"l":"Implement a custom logger","p":["Many applications must integrate with specific remote logging solutions such as Honeycomb and Azure Application Insights. To facilitate this integration, the shell runtime accepts any custom loggers implementing the Logger interface."]},{"l":"Custom logger","p":["First, let's define a custom logger:","Then create a Runtime instance with an instance of the new CustomLogger:"]},{"i":"try-the-logger","l":"Try the logger \uD83D\uDE80","p":["Start the applications and open the developer tools, then, refresh the page. You should see the following console log message:"]}],[{"l":"Develop a module in isolation","p":["To develop their own independent module, a team shouldn't be required to install the host application or any other modules of the application that they do not own. However, they should have a means to integrate their module with the application shell ( RootLayout, RootErrorBoundary, etc..) while working on their module in isolation.","To achieve this, the first step is to extract the application shell from the host application. There are several approaches to accomplish this, but in this guide, we'll transform the host application into a monorepo and introduce a new local package named @sample/shell for this purpose:"]},{"l":"Shell package","p":["The implementation details of the RootLayout and RootErrorBoundary won't be covered by this guide as it already has been covered many times by other guides."]},{"l":"Setup the package","p":["First, add the following fields to the package.json file:","Then, install the package dependencies and configure the new package with tsup."]},{"l":"Create useAppRouter","p":["Finally, create a useAppRouter hook in the shell package. Its purpose is to provide a reusable router configuration that can be utilized by both the host application and the isolated modules. By using this hook, modules developed in isolation can utilize the same application shell and routing configuration as the host application.","This guide only covers the RootLayout and RootErrorBoundary but the same goes for other shell assets such as an AuthenticationBoundary."]},{"l":"Host application"},{"l":"Add the dependencies","p":["Now, let's revisit the host application by first adding a dependency to the new @sample/shell package:"]},{"l":"Use useAppRouter","p":["Then, incorporate the newly introduced useAppRouter hook:"]},{"l":"Remote module","p":["With our new setup in place, we can now configure the remote module to be developed in isolation. The goal is to start the module development server and render the module pages with the same layout and functionalities as if it was rendered by the host application."]},{"i":"add-the-dependencies-1","l":"Add the dependencies","p":["To begin, let's start by adding a dependencies to the @sample/shell package:"]},{"l":"Create the new files","p":["Then, create the following files in the remote module application:"]},{"i":"indextsx","l":"index.tsx","p":["The index.tsx file is similar to the bootstrap.tsx file of an host application but, tailored for an isolated module. The key distinction is that, since the project is set up for local development, the module is registered with the registerLocalModules function instead of the registerRemoteModules function:"]},{"i":"apptsx","l":"App.tsx","p":["The App.tsx file uses the newly created useAppRouter hook to setup React Router with the RootLayout, the RootErrorBoundary and the other shell assets:"]},{"i":"devhometsx","l":"DevHome.tsx","p":["The DevHome component purpose is strictly to serve as an index page when developing the remote module in isolation."]},{"l":"Add a new CLI script","p":["Next, add a new dev-local script to the package.json file to start the local development server in \"isolation\":","The dev-local script is similar to the dev script but introduces a LOCAL environment variable. This new environment variable will be utilized by the webpack.dev.js file to conditionally setup the development server for local development in isolation or to be consumed by a host application through the /remoteEntry.js entry point:"]},{"l":"Configure webpack","p":["If you are having issues configuring webpack, refer to the @workleap/webpack-configs documentation website."]},{"l":"HTML template","p":["First, open the public/index.html file created at the beginning of this guide and copy/paste the following HtmlWebpackPlugin template:"]},{"l":"Browserslist","p":["Then, open the .browserslist file and copy/paste the following content:"]},{"l":"defineDevConfig","p":["To configure webpack, open the webpack.dev.js file and update the configuration to incorporate the LOCAL environment variable and the defineDevConfig function:"]},{"i":"try-it","l":"Try it \uD83D\uDE80","p":["Start the remote module in isolation by running the dev-local script. The application shell should wrap the pages of the module and the default page should be DevHome."]},{"l":"Local module","p":["Similarly to remote modules, the same isolated setup can be achieved for local modules. The main difference is that the webpack.config.js file of a local module serves the sole purpose of starting a development server for isolated development. Typically, local modules do not rely on webpack and Module Federation."]},{"l":"Install the packages","p":["First, open a terminal at the root of the local module application and install the @workleap/webpack-configs package and its dependencies:"]},{"i":"create-the-new-files-1","l":"Create the new files","p":["Then, create the following files in the local module application:"]},{"i":"indextsx-1","l":"index.tsx","p":["This file is similar to the index.tsx file of the remote module."]},{"i":"apptsx-1","l":"App.tsx","p":["This file is similar to the App.tsx file of the remote module."]},{"i":"devhometsx-1","l":"DevHome.tsx","p":["This file is similar to the DevHome.tsx file of the remote module."]},{"i":"configure-webpack-1","l":"Configure webpack","p":["If you are having issues configuring webpack, refer to the @workleap/webpack-configs documentation website."]},{"i":"html-template-1","l":"HTML template","p":["First, open the public/index.html file and copy/paste the following HtmlWebpackPlugin template:"]},{"i":"browserslist-1","l":"Browserslist","p":["Then, open the .browserslist file and copy/paste the following content:"]},{"l":"SWC","p":["Then, open the swc.config.js file and copy/paste the following code:"]},{"i":"definedevconfig-1","l":"defineDevConfig","p":["Finally, open the webpack.config.js file and use the the defineDevConfig function to configure webpack:"]},{"i":"add-a-new-cli-script-1","l":"Add a new CLI script","p":["Next, add a new dev-local script to the package.json file to start the local development server:"]},{"i":"try-it","l":"Try it \uD83D\uDE80","p":["Start the remote module in isolation by running the dev-local script. The application shell should wrap the pages of the module and the default page should be DevHome."]}],[{"l":"Migrating from a monolithic application","p":["Transforming an existing monolithic application into a distributed architecture is often more challenging than building a new federated application from scratch.","However, it's also a bad idea to start a new application with a distributed architecture since teams typically lack sufficient understanding of the business domain at that stage. Therefore, for most applications, it makes sense to begin as monolithic application and transition to a distributed architecture later.","With the introduction of local modules, @squide offers an alternative approach that lies between prior solutions. Instead of immediately embracing Team Topology's stream-aligned teams and striving for full team autonomy across the board, local modules allow teams to start with a monorepo setup and add independent local packages (modules) for each expected value stream.","Since adding/deleting local packages in a monorepo setup is pretty cheap, teams can freely reorganize their value streams along the way and won't preemptively invest into a distributed CI/CD infrastructure as local modules are part of the host application build. With independent but local value streams, teams will be well-positioned to transition toward a federated application once they can justify the cost.","If your project is already a monolithic application with a polyrepo setup and you aim to migrate to a distributed architecture, we recommend a decoupling-first strategy using local modules and a monorepo setup."]},{"l":"Decoupling first","p":["The primary challenge to migrate to a distributed architecture is coupling. Thus, for most applications, starting by decoupling the monolith into composable value streams could be the right strategy. It's a great way to get into the migration without the immediate need to update the CI/CD infrastructure or preemptively change developers' habits.","We recommend the following steps:","Transform the codebase into a monorepo setup.","Create independent local packages (modules) for each identified value stream.","Refactor the monolithic application code into the corresponding value tream local packages and ensure that each value stream can be developed independently(e.g., without the need to start the entire application).","Import and register the local packages(modules) into the host application.","Finally, transition from local modules to remote modules and update your CI/CD pipelines to enable independent deployment of modules.","By following these steps, you can gradually decouple your monolithic application, create modular value streams, and prepare the foundation for a distributed architecture."]}],[{"l":"Reference"},{"l":"Artefacts","p":["Packages"]},{"l":"API"},{"l":"Runtime","p":["Runtime class","RuntimeContext","useRuntime","useRoutes","useNavigationItems","useLogger","useService","useServices","useSession"]},{"l":"Registration","p":["registerLocalModules","registerRemoteModules","registrationStatus","useAreModulesReady"]},{"l":"Routing","p":["useHoistedRoutes","useRenderedNavigationItems"]},{"l":"Logging","p":["Logger","ConsoleLogger"]},{"l":"Messaging","p":["EventBus","useEventBusDispatcher","useEventBusListener"]},{"l":"Session","p":["useIsAuthenticated"]},{"l":"Webpack","p":["defineDevHostConfig","defineDevRemoteModuleConfig","defineBuildHostConfig","defineBuildRemoteModuleConfig"]},{"l":"Fakes","p":["@squide offers a collection of fake implementations to facilitate the development of modules in isolation from the other parts of the application.","LocalStorageSessionManager"]}],[{"l":"Packages","p":["Name","Description","NPM","@squide/core","Core functionalities of @squide.","npm version","@squide/react-router","Specific implementation of the core functionalities to support React Router.","@squide/webpack-module-federation","Add support for Module Federation.","@squide/fakes","A collection of fake implementations to facilitate the development of federated modules."]}],[{"l":"Runtime class","p":["A runtime instance give modules access to functionalities such as routing, navigation and logging."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","mode: An optional mode to optimize @squide for production. Values are development(default) and production.","loggers: An optional array of Logger instances.","services: An optional string-keyed object literal of custom service instances.","sessionAccessor: An optional function returning the current session."]},{"l":"Usage"},{"l":"Create a Runtime instance"},{"l":"Change the runtime mode"},{"l":"Register routes","p":["A @squide route accept any properties of a React Router Route component with the addition of an hoist property."]},{"l":"Register an hoisted page","p":["Unlike a regular page, a hoisted page is added at the root of the router, outside of the boundaries of the host application's root layout. This means that a hoisted page has full control over its rendering.","Setup the host application to accept hoisted routes"]},{"l":"Register routes under a specific nested layout route","p":["React router nested routes enable applications to render nested layouts at various points within the router tree. This is quite helpful for federated applications as it enables composable and decoupled UI.","To fully harness the power of nested routes, the registerRoutes function allows a route to be registered under any previously registered nested layout route, even if that route was registered by another module.","When registering a new route with the registerRoutes function, to render the route under a specific nested layout route, specify a layoutPath property that matches the nested layout route's path property. The only requirement is that the nested layout route must be registered with registerRoutes.","Likewise any other React Router routes, the path property of a page rendered under a nested layout must be an absolute path. For example, if a nested layout path is /layout, the path property of a page rendered under that layout route and responding to the /page-1 url, should be /layout/page-1."]},{"l":"Index routes","p":["Although nested layout routes that serve as indexes (e.g. { index: true, element: Layout / }) are not very common, @squide still supports this scenario. To register a route under an index route, set the layoutPath property as the concatenation of the index route's parent path and /$index$."]},{"l":"Retrieve routes","p":["A federated application routes are accessible from a Runtime instance, but keep in mind that the preferred way to retrieve the routes is with the useRoutes hook."]},{"l":"Register navigation items","p":["A @squide navigation item can either be a NavigationLink or a NavigationSection. Both types can be intertwined to create a multi-level menu hierarchy. A NavigationSection item is used to setup a new level while a NavigationLink define a link.","NavigationSection accept the following properties:","label: The section text.","children: The section content.","priority: An order priority affecting the position of the item in the menu (higher first)","addiltionalProps: Additional properties to be forwarded to the section renderer.","NavigationLink accept any properties of a React Router Link component with the addition of:","label: The link text.","additionalProps: Additional properties to be forwarded to the link renderer.","Setup the host application to render navigation items"]},{"l":"Register nested navigation items"},{"l":"Sort registered navigation items","p":["A priority property can be added to a navigation item to affect it's position in the menu. The sorting algorithm is as follow:","By default a navigation item have a priority of 0.","If no navigation item have a priority, the items are positioned according to their registration order.","If an item have a priority 0, the item will be positioned before any other items with a lower priority (or without an explicit priority value).","If an item have a priority 0, the item will be positioned after any other items with a higher priority (or without an explicit priority value)."]},{"l":"Use a React Element as navigation item label"},{"l":"Style a navigation item"},{"l":"Open a navigation link in a new tab"},{"l":"Render additional props on a navigation item"},{"l":"Register navigation items for a specific menu","p":["By default, every navigation item registered with the registerNavigationItems function is registered as part of the root navigation menu. To register a navigation item for a different navigation menu, specify a menuId property when registering the items."]},{"l":"Retrieve navigation items","p":["A federated application navigation items are accessible from a Runtime instance, but keep in mind that the preferred way to retrieve the navigation items is with the useNavigationItems hook.","By default, the getNavigationItems will return the navigation items for the root menu:","To retrieve the navigation items for a specific navigation menu, provide a menuId:"]},{"l":"Use the logger"},{"l":"Use the event bus"},{"l":"Retrieve a service"},{"l":"Retrieve the current session"}],[{"l":"RuntimeContext","p":["React context to share a Runtime instance between an host application and the modules."]},{"l":"Reference"},{"l":"Parameters","p":["value: A Runtime instance."]},{"l":"Usage"},{"l":"Provide a Runtime instance"},{"l":"Retrieve a Runtime instance"}],[{"l":"useRuntime","p":["Retrive a shared Runtime instance.","When possible, prefer useRoutes, useNavigationItems, useLogger, useServices, useService to useRuntime."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A Runtime instance."]},{"l":"Usage"}],[{"l":"useRoutes","p":["Retrieve the registered routes from the Runtime instance provided by RuntimeContext."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["An array of Route."]},{"l":"Usage"}],[{"l":"useNavigationItems","p":["Retrieve the registered navigation items from the Runtime instance provided by RuntimeContext."]},{"l":"Reference"},{"l":"Parameters","p":["menuId: An optional id to retrieve the navigation menu for a specific menu."]},{"l":"Returns","p":["An array of NavigationItem."]},{"l":"Usage"},{"l":"Retrieve the items for the root menu"},{"l":"Retrieve the items for a specific menu"}],[{"l":"useLogger","p":["Retrieve a RuntimeLogger instance from the Runtime instance provided by RuntimeContext."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A RuntimeLogger instance."]},{"l":"Usage"}],[{"l":"useService","p":["Retrieve a custom service from the Runtime instance provided by RuntimeContext."]},{"l":"Reference"},{"l":"Parameters","p":["name: A custom service instance name."]},{"l":"Returns","p":["A service instance or undefined if the specified service name doesn't match any registered instance."]},{"l":"Usage"}],[{"l":"useServices","p":["Retrieve a string-keyed object literal of custom service instances from the Runtime instance provided by RuntimeContext."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A string-keyed object literal of custom service instances."]},{"l":"Usage"}],[{"l":"useSession","p":["Retrieve the current session from the Runtime instance provided by RuntimeContext."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A custom session object."]},{"l":"Usage"}],[{"l":"registerLocalModules","p":["Register one or many local module(s). During the registration process, the specified registration function will be invoked with a Runtime instance and an optional context object.","A local module is a regular module that is part of the host application build and is bundled at build time, as opposed to remote module which is loaded at runtime from a remote server. Local modules are particularly valuable when undergoing a migration from a monolithic application to a federated application or when launching a new product with an evolving business domain."]},{"l":"Reference"},{"l":"Parameters","p":["registerFunctions: An array of ModuleRegisterFunction.","runtime: A Runtime instance.","options: An optional object literal of options:","context: An optional context object that will be pass to the registration function."]},{"l":"Returns","p":["Nothing"]},{"l":"Usage"}],[{"l":"registerRemoteModules","p":["Register one or many remote module(s). During the registration process, the module register function will be invoked with a Runtime instance and an optional context object.","A remote module is a module that is not part of the current build but is loaded at runtime from a remote server."]},{"l":"Reference"},{"l":"Parameters","p":["remotes: An array of RemoteDefinition(view the Remote definition section).","runtime: A Runtime instance.","options: An optional object literal of options:","context: An optional context object that will be pass to the registration function."]},{"l":"Returns","p":["A Promise object with an array of RegistrationError if any happens during the registration.","RegistrationError:","url: The URL of the module federation remote that failed to load.","containerName: The name of the dynamic container that @squide attempted to recover.","moduleName: The name of the module that @squide attempted to recover.","error: The original error object."]},{"l":"Usage"},{"l":"Remote definition","p":["To ease the configuration of remote modules, make sure that you first import the RemoteDefinition type and assign it to your remote definitions array declaration."]},{"l":"Name","p":["The name property of a remote definition must match the name property defined in the remote module ModuleFederationPlugin configuration.","If you are relying on either the @squide defineDevRemoteModuleConfig or defineBuildRemoteModuleConfig function to add the ModuleFederationPlugin to the remote module webpack configuration object, then the remote module name is the second argument of the function.","In the following exemple, the remote module name is remote1."]},{"l":"Url","p":["The url property of a remote definition must match the publicPath of the remote module webpack configuration object.","In the following exemple, the remote module publicPath is http://localhost:8081.","In development mode, the publicPath is built from the provided host and port values. Therefore, if the port value is 8081, then the generated publicPath would be http://localhost:8081/:","In build mode, the publicPath is the third argument of the defineBuildRemoteModuleConfig function:"]}],[{"l":"registrationStatus","p":["Variable indicating whether or not the remote modules registration process is completed."]},{"l":"Usage"}],[{"l":"useAreModulesReady","p":["Force the application to re-render once all the modules are registered. Without this hook, the page is rendered with an empty router as it happens before the remote modules registered their routes and navigation items.","Only use this hook if your application loads remote modules."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","interval: The interval in milliseconds at which the hook is validating if the registration process is completed."]},{"l":"Returns","p":["A boolean indicating if the registration is completed."]},{"l":"Usage"}],[{"l":"useHoistedRoutes","p":["Allow modules to register pages outside of the host application's elements boundary. Unlike a regular page, an hoisted page is added at the root of the router, meaning before the host application root layout, root error boundary and even root authentication boundary. Thus, an hoisted page has full control over its rendering.","By declaring a page as hoisted, other parts of the application will not be isolated anymore from this page's failures as the page will be rendered outside of the host application's root error boundary. To avoid breaking the entire application when an hoisted page encounters unhandled errors, it is highly recommended to declare a React Router's errorElement property for each hoisted page."]},{"l":"Reference"},{"l":"Parameters","p":["routes: An array of Route to process.","wrapManagedRoutes: A function nesting the managed routes under React elements such as a layout, an error boundary or an authentication boundary.","options: An optional object literal of options:","allowedPaths: An optional array of exclusive route paths available for hosting."]},{"l":"Returns","p":["An array of Route."]},{"l":"Usage"},{"l":"Hoist a module page"},{"l":"Register a module page with a different layout","p":["For a detailed walkthrough, read the guide on how to override the host layout."]},{"l":"Register a public page"},{"l":"Allowing an exclusive set of routes to be hoisted"}],[{"l":"useRenderedNavigationItems","p":["Recursively parse a navigation items structure to transform the items into React Elements.","The useNavigationItems hook returns the navigation items tree structure as is, meaning the consumer has to recursively parse the structure to transform the items into actual React Elements.","As it's a non-trivial process, the shell provides this utility hook to help with that."]},{"l":"Reference"},{"l":"Parameters","p":["navigationItems: An array of NavigationItem to render.","renderItem: A function to render a single link from a navigation item","renderSection: A function to render a section from a collection of items."]},{"l":"Returns","p":["An array of ReactElement."]},{"l":"Usage"}],[{"l":"ConsoleLogger","p":["A basic console logger."]},{"l":"Reference"},{"l":"Parameters","p":["logLevel: An optional minimum level for the logger to output a log entry to the console (default is LogLevel.debug)."]},{"l":"Usage"},{"l":"Log everything"},{"l":"Only log errors","p":["To restrict the logs to error or critical, change the minimum log level to error:"]}],[{"l":"Logger","p":["A basic logger interface."]},{"l":"Usage"}],[{"l":"EventBus","p":["A basic implementation of a pub/sub mecanism enabling loosely coupled between the host application and the modules."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","logger: An optional logger to facilitate debugging."]},{"l":"Usage"},{"l":"Create an EventBus instance"},{"l":"Add a listener","p":["When possible, prefer useEventBusListener to eventBus.addListener."]},{"l":"Remove a listener"},{"l":"Dispatch an event","p":["When possible, prefer useEventBusDispatcher to eventBus.dispatch."]}],[{"l":"useEventBusDispatcher","p":["Retrieve an EventBus instance from the Runtime instance provided by RuntimeContext and provide a function to dispatch an event."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A dispatch function."]},{"l":"Usage"}],[{"l":"useEventBusListener"},{"l":"Reference"},{"l":"Parameters","p":["eventName: The name of the event to listen for.","callback: A function to be executed when a event matching the provided name is dispatched.","options: An optional object literal of options:","once: Whether or not the event listener should be automatically removed once an event as been handled."]},{"l":"Returns","p":["Nothing"]},{"l":"Usage"}],[{"l":"useIsAuthenticated","p":["Indicate whether or not the user is authenticated.","If the sessionAccessor function return a non null/ undefined value, a user is considered as authenticated."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A boolean value."]},{"l":"Usage"}],[{"l":"defineDevHostConfig","p":["Creates a webpack configuration object that is adapted for a @squide host application in development mode."]},{"l":"Reference"},{"l":"Parameters","p":["swcConfig: An SWC configuration object.","applicationName: The host application name.","port: The host application port.","options: An optional object literal of options:","Accepts most of webpack definedDevConfig predefined options.","htmlWebpackPluginOptions: An optional object literal accepting any property of the HtmlWebpackPlugin.","sharedDependencies: An optional object literal of additional (or updated) module federation shared dependencies.","moduleFederationPluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["A webpack configuration object tailored for a @squide host application in development mode."]},{"l":"Default shared dependencies","p":["The defineDevHostConfig function will add the following shared dependencies as singleton by default:","react","react-dom","react-router-dom","@squide/core","@squide/react-router","@squide/webpack-module-federation","For the full shared dependencies configuration, have a look at the defineConfig.ts file on Github."]},{"l":"Usage"},{"l":"Define a webpack config"},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Extend a default shared dependency","p":["In the previous example, the react shared dependency will be augmented with the newly provided strictVersion option. The resulting shared dependency will be:"]},{"l":"Override a default shared dependency","p":["In the previous example, the react shared dependency singleton option will be overrided by the newly provided value. The resulting shared dependency will be:"]},{"l":"Customize module federation configuration","p":["While you could customize the ModuleFederationPlugin configuration by providing your own object literal through the moduleFederationPluginOptions option, we recommend using the defineHostModuleFederationPluginOptions(applicationName, options) function as it will take care of merging the custom options with the default plugin options.","applicationName: The host application name.","moduleFederationPluginOptions: An object literal of ModuleFederationPlugin options."]}],[{"l":"defineDevRemoteModuleConfig","p":["Creates a webpack configuration object that is adapted for a @squide remote module application in development mode."]},{"l":"Reference"},{"l":"Parameters","p":["swcConfig: An SWC configuration object.","applicationName: The remote module application name.","port: The remote module application port.","options: An optional object literal of options:","Accepts most of webpack definedDevConfig predefined options.","sharedDependencies: An optional object literal of additional (or updated) module federation shared dependencies.","moduleFederationPluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["A webpack configuration object tailored for a @squide remote module application in development mode."]},{"l":"Conventions","p":["To fulfill @squide remote module requirements, the defineDevRemoteModuleConfig function will pre-configure the ModuleFederationPlugin with the following filename and exposes properties.","If the remote module port is 8081, the remote module bundle is available at http://localhost:8081/remoteEntry.js."]},{"l":"Default shared dependencies","p":["The defineDevRemoteModuleConfig function will add the following shared dependencies as singleton by default:","react","react-dom","react-router-dom","@squide/core","@squide/react-router","@squide/webpack-module-federation","For the full shared dependencies configuration, have a look at the defineConfig.ts file on Github."]},{"l":"Usage"},{"l":"Define a webpack config"},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Extend a default shared dependency","p":["In the previous example, the react shared dependency will be augmented with the newly provided strictVersion option. The resulting shared dependency will be:"]},{"l":"Override a default shared dependency","p":["In the previous example, the react shared dependency singleton option will be overrided by the newly provided value. The resulting shared dependency will be:"]},{"l":"Customize module federation configuration","p":["While you could customize the ModuleFederationPlugin configuration by providing your own object literal through the moduleFederationPluginOptions option, we recommend using the defineRemoteModuleFederationPluginOptions(applicationName, options) function as it will take care of merging the custom options with the default plugin options.","applicationName: The host application name.","moduleFederationPluginOptions: An object literal of ModuleFederationPlugin options."]},{"l":"Expose an additional module"}],[{"l":"defineBuildHostConfig","p":["Creates a webpack configuration object that is adapted for a @squide host application in build mode."]},{"l":"Reference"},{"l":"Parameters","p":["swcConfig: An SWC configuration object.","applicationName: The host application name.","publicPath: The host application public path.","options: An optional object literal of options:","Accepts most of webpack definedBuildConfig predefined options.","htmlWebpackPluginOptions: An optional object literal accepting any property of the HtmlWebpackPlugin.","sharedDependencies: An optional object literal of additional (or updated) module federation shared dependencies.","moduleFederationPluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["A webpack configuration object tailored for a @squide host application in build mode."]},{"l":"Default shared dependencies","p":["The defineBuildHostConfig function will add the following shared dependencies as singleton by default:","react","react-dom","react-router-dom","@squide/core","@squide/react-router","@squide/webpack-module-federation","For the full shared dependencies configuration, have a look at the defineConfig.ts file on GitHub."]},{"l":"Usage"},{"l":"Define a webpack config"},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Extend a default shared dependency","p":["In the previous example, the react shared dependency will be augmented with the newly provided strictVersion option. The resulting shared dependency will be:"]},{"l":"Override a default shared dependency","p":["In the previous example, the react shared dependency singleton option will be overrided by the newly provided value. The resulting shared dependency will be:"]},{"l":"Customize module federation configuration","p":["While you could customize the ModuleFederationPlugin configuration by providing your own object literal through the moduleFederationPluginOptions option, we recommend using the defineHostModuleFederationPluginOptions(applicationName, options) function as it will take care of merging the custom options with the default plugin options.","applicationName: The host application name.","moduleFederationPluginOptions: An object literal of ModuleFederationPlugin options."]}],[{"l":"defineBuildRemoteModuleConfig","p":["Creates a webpack configuration object that is adapted for a @squide remote module application in build mode."]},{"l":"Reference"},{"l":"Parameters","p":["swcConfig: An SWC configuration object.","applicationName: The remote module application name.","publicPath: The remote module application public path.","options: An optional object literal of options:","Accepts most of webpack definedDevConfig predefined options.","sharedDependencies: An optional object literal of additional (or updated) module federation shared dependencies.","moduleFederationPluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["A webpack configuration object tailored for a @squide remote module application in build mode."]},{"l":"Conventions","p":["To fulfill @squide remote module requirements, the defineBuildRemoteModuleConfig function will pre-configure the ModuleFederationPlugin with the following filename and exposes properties.","If the remote module publicPath is http://localhost/8081, the remote module bundle is available at http://localhost:8081/remoteEntry.js."]},{"l":"Default shared dependencies","p":["The defineBuildRemoteModuleConfig function will add the following shared dependencies as singleton by default:","react","react-dom","react-router-dom","@squide/core","@squide/react-router","@squide/webpack-module-federation","For the full shared dependencies configuration, have a look at the defineConfig.ts file on Github."]},{"l":"Usage"},{"l":"Define a webpack config"},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Extend a default shared dependency","p":["In the previous example, the react shared dependency will be augmented with the newly provided strictVersion option. The resulting shared dependency will be:"]},{"l":"Override a default shared dependency","p":["In the previous example, the react shared dependency singleton option will be overrided by the newly provided value. The resulting shared dependency will be:"]},{"l":"Customize module federation configuration","p":["While you could customize the ModuleFederationPlugin configuration by providing your own object literal through the moduleFederationPluginOptions option, we recommend using the defineRemoteModuleFederationPluginOptions(applicationName, options) function as it will take care of merging the custom options with the default plugin options.","applicationName: The host application name.","moduleFederationPluginOptions: An object literal of ModuleFederationPlugin options."]},{"l":"Expose an additional module"}],[{"l":"LocalStorageSessionManager","p":["A local storage session manager strictly for development purpose."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","key: An optional key identifying the session in localStorage."]},{"l":"Usage"},{"l":"Create a manager instance"},{"l":"Set a session"},{"l":"Get the current session"},{"l":"Clear the current session"},{"l":"Integrate with a Runtime instance"}],[{"l":"Samples"},{"i":"squide-sandbox","l":"@squide sandbox","p":["Host application","Remote module","Local module","Live sample"]}],[{"l":"About","p":["To ask a question or propose an idea, feel free to start a new discussion on Github. If you found a bug, please open an issue on Github."]},{"l":"Contributing","p":["Have a look at the contributor's documentation."]},{"l":"License","p":["See the LICENSE on Github."]}]]